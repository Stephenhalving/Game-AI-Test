extends CharacterBody2D

@export var speed := 170.0
@export var gravity := 1200.0
@export var jump_velocity := -420.0

@export var max_hp := 10
var hp := 10

var facing := 1.0
var invuln := 0.0
var hurt_timer := 0.0
var hurt_knock_x := 0.0

var last_action := "IDLE"
# bloquea el auto-switch idle/run por un ratito (para ataques, hurt, etc.)
var anim_lock := 0.0

# --- STATE (estructura) ---
enum State { IDLE, RUN, JUMP, ATK, HEAVY, HURT, KO }
var state: int = State.IDLE

@export var accel := 1200.0
@export var friction := 1400.0
@export var max_fall := 900.0

# salto “pro”: coyote + buffer
@export var coyote_time := 0.10
@export var jump_buffer := 0.10
var coyote := 0.0
var jbuf := 0.0

var action_timer := 0.0

var combo_step := 0
var combo_timer := 0.0
var combo_window := 0.35

var attack_cooldown := 0.0
var current_damage := 1
var current_knock := 260.0
var current_lift := 0.0
var last_attack_heavy := false

# evita multi-hit por misma ventana
var attack_consumed := false

@onready var attack_area: Area2D = get_node_or_null("AttackArea")
@onready var body_poly: Polygon2D = get_node_or_null("Visual/PlayerBody")
@onready var cam: Camera2D = get_node_or_null("Camera2D")
@onready var anim: AnimationPlayer = get_node_or_null("AnimationPlayer")
@onready var floor_ray: RayCast2D = $FloorRay
@onready var wall_left: RayCast2D = $WallRayLeft
@onready var wall_right: RayCast2D = $WallRayRight
@onready var hurt_area: Area2D = $HurtArea

func _ready() -> void:
    add_to_group("player")
    print("✅ Player READY")
    hp = max_hp

    if attack_area:
        attack_area.monitoring = false
        if not attack_area.body_entered.is_connected(_on_attack_area_body_entered):
            attack_area.body_entered.connect(_on_attack_area_body_entered)

    if anim:
        anim.play("idle")

func _physics_process(delta: float) -> void:
    # DEBUG INPUT/STATS (auto)
    if Engine.get_physics_frames() % 30 == 0:
        print("INP L=", Input.is_action_pressed("move_left"),
            " R=", Input.is_action_pressed("move_right"),
            " dir=", Input.get_axis("move_left", "move_right"))

    # --- INPUT ---
    var dir := Input.get_axis("move_left", "move_right")
    if abs(dir) < 0.01:
        dir = Input.get_axis("ui_left", "ui_right")

    # HEADLESS AUTOPILOT: fuerza movimiento para test
    if DisplayServer.get_name() == "headless":
        dir = 1.0

    
    var pressed_attack := Input.is_action_just_pressed("attack")
    var pressed_heavy := Input.is_action_just_pressed("heavy")

    # DEBUG (cada ~0.5s)
    if Engine.get_physics_frames() % 30 == 0:
        print("DBG dir=", dir, " vel=", velocity, " on_floor=", is_on_floor(), " pos=", global_position)


        # --- TIMERS ---
        action_timer = max(0.0, action_timer - delta)
        attack_cooldown = max(0.0, attack_cooldown - delta)
        combo_timer = max(0.0, combo_timer - delta)
        invuln = max(0.0, invuln - delta)
        hurt_timer = max(0.0, hurt_timer - delta)
        anim_lock = max(0.0, anim_lock - delta)

        # --- JUMP BUFFER + COYOTE ---
        if pressed_jump:
            jbuf = jump_buffer
        else:
            jbuf = max(0.0, jbuf - delta)

        if is_on_floor():
            coyote = coyote_time
        else:
            coyote = max(0.0, coyote - delta)

        if dir < -0.01:
                facing = -1.0
        elif dir > 0.01:
                facing = 1.0

        # --- VISUAL FLIP (arcade) ---
        if body_poly:
            body_poly.scale.x = abs(body_poly.scale.x) * facing

        # --- CONTROL GATE (DEFINIR ANTES DE USAR) ---
        var can_control := (hurt_timer <= 0.0) and (state != State.ATK) and (state != State.HEAVY) and (state != State.KO)

        # heavy (K)
        if pressed_heavy and attack_cooldown <= 0.0 and can_control:
            _do_heavy_attack()

        # combo normal (J)
        if pressed_attack and attack_cooldown <= 0.0 and can_control:
            _do_combo_attack()


        if not is_on_floor():
            velocity.y += gravity * delta
            if velocity.y > max_fall:
                velocity.y = max_fall
        else:
           if can_control:
               if jbuf > 0.0 and coyote > 0.0:
                   jbuf = 0.0
                   coyote = 0.0
                   velocity.y = jump_velocity
                   state = State.JUMP
                   _set_action("JUMP", 0.25)

        # --- APPLY HORIZONTAL MOVE (mejor control) ---
        if can_control:
            if abs(dir) > 0.01:
                velocity.x = move_toward(velocity.x, dir * speed, accel * delta)
            else:
                velocity.x = move_toward(velocity.x, 0.0, friction * delta)
        else:
            if state == State.HURT:
                velocity.x = hurt_knock_x

        # --- salir de ATK/HEAVY cuando termina el lock ---
        if anim_lock <= 0.0 and (state == State.ATK or state == State.HEAVY):
            state = State.IDLE

        # --- estados base ---
        if state != State.HURT and state != State.KO and state != State.ATK and state != State.HEAVY:
            if not is_on_floor():
                state = State.JUMP
            elif abs(velocity.x) > 5.0:
                state = State.RUN
            else:
                state = State.IDLE

        # --- Basic animation switch ---
        # No pisar anims de ataque mientras anim_lock > 0
        if can_control and anim_lock <= 0.0:
            if abs(velocity.x) > 1.0 and is_on_floor():
                if anim and anim.current_animation != "run":
                    anim.play("run")
            else:
                if anim and anim.current_animation != "idle":
                    anim.play("idle")
   
        # DEBUG piso (cada ~0.5s)
        if Engine.get_physics_frames() % 30 == 0:
            print("floor=", is_on_floor(), " pos=", global_position, " vel=", velocity)

        move_and_slide()

        if Engine.get_physics_frames() % 30 == 0 and floor_ray:
            print("floor_ray=", floor_ray.is_colliding(), " on_floor=", is_on_floor(), " vel=", velocity)

        # blink invuln (proteger null)
        if body_poly:
            body_poly.visible = true if int(Time.get_ticks_msec() / 80) % 2 == 0 or invuln <= 0.0 else false

func _do_heavy_attack() -> void:
    state = State.HEAVY
    anim_lock = 0.26
    last_attack_heavy = true
    combo_step = 0
    combo_timer = 0.0
    current_damage = 2
    current_knock = 420.0
    current_lift = 420.0

    # --- A4PRO: lock + anim ---
    anim_lock = 0.26
    if anim and anim.has_animation("heavy"):
        anim.play("heavy")

    _set_action("HEAVY", 0.26)
    attack_cooldown = 0.22
    _do_attack_window()

func _do_combo_attack() -> void:
    state = State.ATK
    anim_lock = 0.18
    last_attack_heavy = false

    # Si se venció la ventana, reinicia el combo
    if combo_timer <= 0.0:
        combo_step = 1
    else:
        combo_step += 1
        if combo_step > 3:
            combo_step = 1

    # --- A4PRO: lock + anim de combo ---
    anim_lock = 0.18
    if anim:
        # Si existen anims por golpe, mejor:
        if combo_step == 1 and anim.has_animation("atk1"):
            anim.play("atk1")
        elif combo_step == 2 and anim.has_animation("atk2"):
            anim.play("atk2")
        elif combo_step == 3 and anim.has_animation("atk3"):
            anim.play("atk3")
        elif anim.has_animation("attack"):
            anim.play("attack")

    # HUD combo text (x1/x2/x3)
    var main := get_tree().current_scene
    if main and main.has_node("HUD"):
        var h := main.get_node("HUD")
        if h and h.has_method("set_combo"):
            h.set_combo("x%d" % combo_step)

    # Aplicar stats por golpe
    if combo_step == 1:
        current_damage = 1
        current_knock = 220.0
        current_lift = 0.0
        _set_action("ATK1", 0.18)
    elif combo_step == 2:
        current_damage = 1
        current_knock = 260.0
        current_lift = 0.0
        _set_action("ATK2", 0.18)
    else:
        current_damage = 2
        current_knock = 360.0
        current_lift = 180.0
        _set_action("ATK3", 0.22)

    attack_cooldown = 0.12
    combo_timer = combo_window
    _do_attack_window()

func _do_attack_window() -> void:
    attack_consumed = false
    attack_area.position.x = 18.0 * facing
    attack_area.set_deferred("monitoring", true)

    # Esperar 1 frame de física para que el motor compute overlaps
    await get_tree().physics_frame

    # Si ya estaba solapando, body_entered no siempre dispara: pegamos por overlap también
    var bodies: Array[Node2D] = attack_area.get_overlapping_bodies()
    for b in bodies:
        if attack_consumed:
            break
        _on_attack_area_body_entered(b)

    # Ventana activa del hitbox (por si entra alguien durante el golpe)
    await get_tree().create_timer(0.10).timeout
    attack_area.set_deferred("monitoring", false)

func _on_attack_area_body_entered(body: Node) -> void:
    if body == self:
        return
    if body.has_method("take_hit") and not attack_consumed:
        attack_consumed = true
        body.take_hit(facing, current_knock, current_damage, current_lift)

        # hitstop si existe
        var main: Node = get_tree().current_scene
        if main and main.has_method("hitstop"):
            if last_attack_heavy:
                main.hitstop(0.09, 0.04)
            else:
                main.hitstop(0.05, 0.08)

        # shake si existe
        if last_attack_heavy and has_method("_shake_cam"):
            _shake_cam(4.0, 0.11)

func take_damage(from_dir: float, dmg: int = 1, knock: float = 360.0) -> void:
    if invuln > 0.0:
        return
    hp -= dmg
    invuln = 0.8
    hurt_timer = 0.18
    hurt_knock_x = knock * from_dir
    _set_action("HURT", 0.25)
    if hp <= 0:
        _set_action("KO", 1.0)

func _set_action(name: String, seconds: float) -> void:
    last_action = name
    action_timer = seconds

# --- Camera shake helper (seguro) ---
func _shake_cam(intensity: float = 3.0, duration: float = 0.10) -> void:
    if not cam:
        return
    var base: Vector2 = cam.position
    var steps: int = 6
    var step_t: float = duration / float(steps)
    if step_t < 0.01:
        step_t = 0.01
    for i in range(steps):
        var off: Vector2 = Vector2(
            randf_range(-intensity, intensity),
            randf_range(-intensity, intensity)
        )
        cam.position = base + off
        await get_tree().create_timer(step_t).timeout
    cam.position = base
