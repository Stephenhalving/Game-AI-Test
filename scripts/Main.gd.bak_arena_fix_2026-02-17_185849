extends Node2D

const LevelConfig = preload("res://scripts/LevelConfig.gd")
const RUSHER_SCENE := preload("res://scenes/EnemyRusher.tscn")
const TANK_SCENE := preload("res://scenes/EnemyTank.tscn")
const RANGED_SCENE := preload("res://scenes/EnemyRanged.tscn")

const COIN_SCENE := preload("res://scenes/Coin.tscn")
const FOOD_SCENE := preload("res://scenes/Food.tscn")
const KEY_SCENE := preload("res://scenes/Key.tscn")

@export var max_enemies := 3

var enemies: Array[Node] = []
var score := 0
var wave := 0
var has_key := false
var level_id: int = 1
var cfg: Dictionary = {}
var arena_active := false
var arena_cleared := false
var arena_wave_index := 0
var arena_total_waves := 3
var arena_wave_left := 0
var arena_waiting_next_wave := false

@onready var arena_spawn_points := get_tree().get_nodes_in_group("arena_spawn")
@export var headless_autoplay: bool = false
@onready var hud := $HUD
@onready var door := get_node_or_null("Door")

# --- ARENA GATE (Scott Pilgrim loop) ---
const ENEMY_RUSHER := preload("res://scenes/EnemyRusher.tscn")
const ENEMY_TANK := preload("res://scenes/EnemyTank.tscn")
const ENEMY_RANGED := preload("res://scenes/EnemyRanged.tscn")

@onready var arena_trigger: Area2D = get_node_or_null("Level/ArenaTrigger")
@onready var door_node: Node = get_node_or_null("Door")

func _ready() -> void:
    print("ðŸ§± Main._ready() ENTER")
    print("ðŸ§± arena_trigger=", arena_trigger)
    print("ðŸ§± arena_trigger_path=", arena_trigger.get_path() if arena_trigger else "NULL")
    add_to_group("main")

    # --- Level config (F7.2) ---
    get_tree().paused = false
    Engine.time_scale = 1.0
    print("âœ… Main READY paused=", get_tree().paused, " time_scale=", Engine.time_scale)
    var lm := get_node_or_null("/root/LevelManagerAuto")
    
    if lm != null:
        level_id = int(lm.get("current_level"))
    else:
        level_id = 1
        
    # --- ArenaTrigger hook ---
    if arena_trigger and not arena_trigger.body_entered.is_connected(_on_arena_trigger_body_entered):
        arena_trigger.body_entered.connect(_on_arena_trigger_body_entered)
        print("ðŸŸ© ArenaTrigger CONNECTED OK -> ", arena_trigger.get_path())
    else:
        print("ðŸŸ¥ ArenaTrigger missing or already connected: ", arena_trigger)

    # OJO: esto requiere que exista LevelConfig.gd y class_name LevelConfig
    cfg = LevelConfig.get_level(level_id)
    max_enemies = int(cfg.get("max_enemies", max_enemies))

    # resto igual...


    var g = get_node_or_null("Ground")
    var gy := "NONE"
    if g:
        gy = str(g.position.y)

    randomize()
    if hud and hud.has_method("set_score"):
        hud.set_score(score)
    if hud and hud.has_method("set_key"):
        hud.set_key(false)

    _spawn_to_max()

    if DisplayServer.get_name() == "headless":
        print("ðŸ§ª HEADLESS: forcing arena start for test")
        _start_arena()

func _lock_door(locked: bool) -> void:
    # locked=true => door closed
    # locked=false => door open
    if door_node == null:
        push_warning("Door node not found. Skipping lock/unlock.")
        return

    if locked:
        # close door
        if door_node.has_method("set"):
            door_node.set("is_open", false)
        elif door_node.has_method("close"):
            door_node.call("close")
        # intentar forzar update si existe
        if door_node.has_method("_update_state_deferred"):
            door_node.call("_update_state_deferred")
        return

    # unlock => open door
    if door_node.has_method("open"):
        door_node.call("open")
        return

    # fallback: set flag and update
    if door_node.has_method("set"):
        door_node.set("is_open", true)
        if door_node.has_method("_update_state_deferred"):
            door_node.call("_update_state_deferred")

func _start_arena():
    if arena_active:
        return

    arena_cleared = false
    arena_wave_index = 0
    arena_total_waves = 3 # por ahora fijo

    _lock_door(true)
    _spawn_next_wave()

func _spawn_next_wave():
    arena_wave_index += 1
    if arena_wave_index > arena_total_waves:
        _finish_arena()
        return

    var plan := _build_wave_plan(arena_wave_index)
    arena_wave_left = plan.size()

    # Spawn escalonado para que no se encimen (feeling arcade/brawler)
    for enemy_scene_path in plan:
        _spawn_enemy_from_path(enemy_scene_path)
        await get_tree().create_timer(0.35).timeout

func _spawn_to_max() -> void:
    if arena_active:
        return
    _cleanup_dead()
    arena_wave_index += 1
    if arena_wave_index > arena_total_waves:
        _finish_arena()
        return

    var plan := _build_wave_plan(arena_wave_index)
    arena_wave_left = plan.size()

    for enemy_scene_path in plan:
        _spawn_enemy_from_path(enemy_scene_path)

func _build_wave_plan(wave: int) -> Array:
    var rusher := "res://scenes/EnemyRusher.tscn"
    var tank := "res://scenes/EnemyTank.tscn"
    var ranged := "res://scenes/EnemyRanged.tscn"

    match wave:
        1:
            return [rusher, rusher, rusher]
        2:
            return [rusher, rusher, ranged]
        3:
            return [tank, rusher, rusher]
        _:
            return [tank, ranged, rusher, rusher]

func _spawn_enemy_from_path(scene_path: String):
    var packed := load(scene_path)
    if packed == null:
        push_error("Enemy scene not found: %s" % scene_path)
        return

    var enemy: Node = packed.instantiate()
    add_child(enemy)

    # spawn pos
    var pos := _pick_arena_spawn_position()
    if enemy is Node2D:
        enemy.global_position = pos

    # connect died
    if enemy.has_signal("died"):
        enemy.connect("died", Callable(self, "_on_arena_enemy_died").bind(enemy))

func _spawn_to_max_legacy() -> void:
    _cleanup_dead()
    while enemies.size() < max_enemies:
        var scene := _pick_enemy_scene()
        var e: Node = scene.instantiate()
        add_child(e)
        e.name = "Enemy_%d" % Time.get_ticks_msec()
        e.global_position = Vector2(320 + enemies.size() * 34, 120)
        enemies.append(e)
        if e.has_signal("died"):
            e.died.connect(func(): _on_enemy_died(e))

func _cleanup_dead() -> void:
    var alive: Array[Node] = []
    for e in enemies:
        if e and is_instance_valid(e):
            alive.append(e)
    enemies = alive

func _pick_enemy_scene() -> PackedScene:
    var r := randf()
    if r < 0.4:
        return RUSHER_SCENE
    elif r < 0.7:
        return TANK_SCENE
    else:
        return RANGED_SCENE

func add_score(v: int) -> void:
    score += v
    if hud and hud.has_method("set_score"):
        hud.set_score(score)

func on_key_collected() -> void:
    if arena_active:
        return
    has_key = true
    if hud and hud.has_method("set_key"):
        hud.set_key(true)

func _drop_loot(pos: Vector2) -> void:
    var r := randf()
    if r < 0.5:
        var c = COIN_SCENE.instantiate()
        add_child(c)
        c.global_position = pos
    elif r < 0.75:
        var f = FOOD_SCENE.instantiate()
        add_child(f)
        f.global_position = pos
    else:
        if not has_key:
            var k = KEY_SCENE.instantiate()
            add_child(k)
            k.global_position = pos

func _on_enemy_died(e: Node) -> void:
    add_score(100)
    if e and is_instance_valid(e):
        call_deferred("_drop_loot", e.global_position)
    if enemies.has(e):
        enemies.erase(e)
    wave += 1
    _spawn_to_max()

func _pick_arena_spawn_position() -> Vector2:
    if arena_spawn_points.size() > 0:
        var sp := arena_spawn_points[randi() % arena_spawn_points.size()]
        if sp is Node2D:
            return sp.global_position
    return Vector2.ZERO

func on_level_complete() -> void:
    add_score(250)
    print("âœ… STAGE CLEAR +250")
    await get_tree().create_timer(0.6).timeout

    var lm := get_node_or_null("/root/LevelManagerAuto")
    if lm:
        lm.call_deferred("next_level")
    else:
        # fallback (por si autoload no existe)
        get_tree().reload_current_scene()

func on_player_died() -> void:
    print("ðŸ” RESTARTING SCENE...")
    await get_tree().create_timer(0.8).timeout
    get_tree().reload_current_scene()

# --- Floating damage text (reusable) ---
func spawn_damage_text(pos: Vector2, amount: int) -> void:
    # Si existe un nodo/escena DamageText, lo instancia. Si no, usa texto flotante simple.
    if ResourceLoader.exists("res://scenes/DamageText.tscn"):
        var dt = preload("res://scenes/DamageText.tscn").instantiate()
        add_child(dt)
        dt.global_position = pos
        if dt.has_method("set_amount"):
            dt.set_amount(amount)
        elif dt.has_method("set_text"):
            dt.set_text(str(amount))
    else:
        # fallback: usa spawn_floating_text si estÃ¡
        if has_method("spawn_floating_text"):
            spawn_floating_text(pos, str(amount))
        else:
            print("DMG:", amount)

# Alias por compatibilidad
func spawn_floating_text(pos: Vector2, text: String) -> void:
    # Si te mandan string, intenta parsear nÃºmero; sino lo imprime como texto
    var n := int(text) if text.is_valid_int() else 0
    if n != 0:
        spawn_damage_text(pos, n)
    else:
        print("FLOAT:", text)

func _on_arena_trigger_body_entered(body: Node) -> void:
    if arena_active or arena_cleared:
        return
    if body == null:
        return
    if not body.is_in_group("player"):
        return    
    # solo el Player activa
    if body.name != "Player":
        return

    print("ðŸŸ¨ ArenaTrigger ENTER -> START ARENA")
    _start_arena()

func _spawn_arena_wave() -> void:
    print("ðŸ§ª _spawn_arena_wave() ENTER")

    var spawn_y := 170.0
    var spawns := [
        Vector2(320.0, spawn_y),
        Vector2(370.0, spawn_y),
        Vector2(420.0, spawn_y),
    ]
    var pool: Array[PackedScene] = [ENEMY_RUSHER, ENEMY_TANK, ENEMY_RANGED]

    for i in range(spawns.size()):
        var scene: PackedScene = pool[i % pool.size()]
        var e: Node2D = scene.instantiate()
        add_child(e)
        e.global_position = spawns[i]

        # contar vivos de arena
        arena_wave_left += 1

        # registrar tambiÃ©n para respawn general
        enemies.append(e)

        # marcar como enemigo de arena (opcional)
        e.add_to_group("arena_enemy")

        print("ðŸ§ª spawned arena enemy #", i, " wave_left=", arena_wave_left)

        if e.has_signal("died"):
            # 1) contador de arena
            e.died.connect(_on_arena_enemy_died)
            # 2) sistema general (score/loot/respawn)
            e.died.connect(func(): _on_enemy_died(e))

func _on_arena_enemy_died(enemy):
    arena_wave_left -= 1

    if arena_wave_left <= 0:
        if arena_waiting_next_wave:
            return
        arena_waiting_next_wave = true

        await get_tree().create_timer(1.25).timeout

        arena_waiting_next_wave = false
        _spawn_next_wave()

func _finish_arena():
    arena_active = false
    arena_cleared = true

    # âœ… dar llave SOLO al finalizar la arena
    _grant_arena_key()

    _lock_door(false)

func _grant_arena_key() -> void:
    if has_key:
        return
    has_key = true
    if hud and hud.has_method("set_key"):
        hud.set_key(true)

func _start_arena_legacy():
    arena_active = true
    arena_cleared = false
    arena_wave_left = 0

    print("ðŸ§ª _start_arena() -> calling _spawn_arena_wave()")
    _spawn_arena_wave()

    if door_node and door_node.has_method("set_locked"):
        door_node.call("set_locked", true)    

func _set_door_exit_enabled(enabled: bool) -> void:
    if door_node == null:
        return

    var exit_area: Area2D = door_node.get_node_or_null("ExitArea")
    if exit_area:
        exit_area.set_deferred("monitoring", enabled)
