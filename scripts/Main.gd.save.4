extends Node2D

const LevelConfig = preload("res://scripts/LevelConfig.gd")
const RUSHER_SCENE := preload("res://scenes/EnemyRusher.tscn")
const TANK_SCENE := preload("res://scenes/EnemyTank.tscn")
const RANGED_SCENE := preload("res://scenes/EnemyRanged.tscn")
const ARENA_SPAWN_MIN_X := 40.0
const ARENA_SPAWN_MAX_X := 480.0
const ARENA_SPAWN_MIN_Y := 110.0
const ARENA_SPAWN_MAX_Y := 190.0

const COIN_SCENE := preload("res://scenes/Coin.tscn")
const FOOD_SCENE := preload("res://scenes/Food.tscn")
const KEY_SCENE := preload("res://scenes/Key.tscn")

@export var max_enemies := 3

var enemies: Array[Node] = []
var score := 0
var wave := 0
var has_key := false
var level_id: int = 1
var cfg: Dictionary = {}
var arena_active := false
var arena_cleared := false
var arena_wave_index := 0
var arena_total_waves := 3
var arena_wave_left := 0
var arena_waiting_next_wave := false

var arena_spawn_points: Array = []
@export var headless_autoplay: bool = false
@onready var hud := $HUD
@onready var door := get_node_or_null("Door")

# --- ARENA GATE (Scott Pilgrim loop) ---
const ENEMY_RUSHER := preload("res://scenes/EnemyRusher.tscn")
const ENEMY_TANK := preload("res://scenes/EnemyTank.tscn")
const ENEMY_RANGED := preload("res://scenes/EnemyRanged.tscn")

@onready var arena_trigger: Area2D = get_node_or_null("Level/ArenaTrigger")
@onready var door_node: Node = get_node_or_null("Door")

func _ready() -> void:
    print("ðŸ§± Main._ready() ENTER")
    print("ðŸ§± arena_trigger=", arena_trigger)
    print("ðŸ§± arena_trigger_path=", arena_trigger.get_path() if arena_trigger else "NULL")
    add_to_group("main")

    # --- Level config (F7.2) ---
    get_tree().paused = false
    Engine.time_scale = 1.0
    print("âœ… Main READY paused=", get_tree().paused, " time_scale=", Engine.time_scale)
    var lm := get_node_or_null("/root/LevelManagerAuto")
    
    if lm != null:
        level_id = int(lm.get("current_level"))
    else:
        level_id = 1
        
    # --- ArenaTrigger hook ---
    if arena_trigger and not arena_trigger.body_entered.is_connected(_on_arena_trigger_body_entered):
        arena_trigger.body_entered.connect(_on_arena_trigger_body_entered)
        print("ðŸŸ© ArenaTrigger CONNECTED OK -> ", arena_trigger.get_path())
    else:
        print("ðŸŸ¥ ArenaTrigger missing or already connected: ", arena_trigger)

    # OJO: esto requiere que exista LevelConfig.gd y class_name LevelConfig
    cfg = LevelConfig.get_level(level_id)
    max_enemies = int(cfg.get("max_enemies", max_enemies))

    arena_spawn_points = []
    var level := get_node_or_null("Level")
    if level:
        var nodes := level.find_children("*", "Node2D", true, false)
        for n in nodes:
            if n.is_in_group("arena_spawn"):
                arena_spawn_points.append(n)
    print("ðŸ§­ arena_spawn_points=", arena_spawn_points.size())

    var g = get_node_or_null("Ground")
    var gy := "NONE"
    if g:
        gy = str(g.position.y)

    randomize()
    if hud and hud.has_method("set_score"):
        hud.set_score(score)
    if hud and hud.has_method("set_key"):
        hud.set_key(false)

    _spawn_to_max()

    if DisplayServer.get_name() == "headless":
        print("ðŸ§ª HEADLESS: forcing arena start for test")
        call_deferred("_headless_test_run")
        return

func _headless_test_run() -> void:
    print("ðŸ§ª HEADLESS: _headless_test_run() ENTER")

    # arrancar arena
    _start_arena()

    # esperar para que spawnee y corra
    await get_tree().create_timer(6.0, false, true).timeout

    # log de estado (no importa si alguna variable falla, lo ajustamos)
    print("ðŸ§ª HEADLESS STATUS:",
        " arena_active=", arena_active,
        " arena_wave_left=", arena_wave_left,
        " enemies=", enemies.size()
    )

    print("ðŸ§ª HEADLESS: quitting")
    get_tree().quit()

func _lock_door(locked: bool) -> void:
    # locked=true => door closed
    # locked=false => door open
    if door_node == null:
        push_warning("Door node not found. Skipping lock/unlock.")
        return

    if locked:
        # close door
        if door_node.has_method("set"):
            door_node.set("is_open", false)
        elif door_node.has_method("close"):
            door_node.call("close")
        # intentar forzar update si existe
        if door_node.has_method("_update_state_deferred"):
            door_node.call("_update_state_deferred")
        return

    # unlock => open door
    if door_node.has_method("open"):
        door_node.call("open")
        return

    # fallback: set flag and update
    if door_node.has_method("set"):
        door_node.set("is_open", true)
        if door_node.has_method("_update_state_deferred"):
            door_node.call("_update_state_deferred")



func _spawn_next_wave():
    # Beat pause (Scott Pilgrim vibe)
    get_tree().paused = true
    await get_tree().create_timer(0.12, true).timeout
    get_tree().paused = false

    # PequeÃ±o "ready" delay antes de que entren
    await get_tree().create_timer(0.35).timeout

    arena_wave_index += 1
    if arena_wave_index > arena_total_waves:
        _finish_arena()
        return

    var plan := _build_wave_plan(arena_wave_index)
    arena_wave_left = plan.size()

    # Spawn escalonado para que no se encimen (feeling arcade/brawler)
    for enemy_scene_path in plan:
        _spawn_enemy_from_path(enemy_scene_path)
        await get_tree().create_timer(0.35).timeout

func _spawn_to_max() -> void:
    # Wrapper: el spawner general usa la versiÃ³n legacy
    _spawn_to_max_legacy()

func _build_wave_plan(wave: int) -> Array:
    var rusher := "res://scenes/EnemyRusher.tscn"
    var tank := "res://scenes/EnemyTank.tscn"
    var ranged := "res://scenes/EnemyRanged.tscn"

    match wave:
        1:
            return [rusher, rusher, rusher]
        2:
            return [rusher, rusher, ranged]
        3:
            return [tank, rusher, rusher]
        _:
            return [tank, ranged, rusher, rusher]

func _spawn_enemy_from_path(scene_path: String):
    var packed := load(scene_path)
    if packed == null:
        push_error("Enemy scene not found: %s" % scene_path)
        return

    var enemy: Node = packed.instantiate()
    add_child(enemy)

    var sp2: Node2D = _pick_arena_spawn_point()
    var pos: Vector2 = sp2.global_position if sp2 != null else Vector2.ZERO

    if enemy is Node2D:
        var n := enemy as Node2D

        # "entrada" estilo brawler: spawn desplazado y tween al punto
        var offset := Vector2.ZERO
        var nm := String(sp2.name) if sp2 != null else ""

        if nm.find("Left") != -1:
            offset = Vector2(-80, 0)
        elif nm.find("Right") != -1:
            offset = Vector2(80, 0)
        elif nm.find("Top") != -1:
            offset = Vector2(0, -60)    

        pos.x = clamp(pos.x, ARENA_SPAWN_MIN_X, ARENA_SPAWN_MAX_X)
        pos.y = clamp(pos.y, ARENA_SPAWN_MIN_Y, ARENA_SPAWN_MAX_Y)

        var start_pos := pos + offset
        start_pos.x = clamp(start_pos.x, ARENA_SPAWN_MIN_X, ARENA_SPAWN_MAX_X)
        start_pos.y = clamp(start_pos.y, ARENA_SPAWN_MIN_Y, ARENA_SPAWN_MAX_Y)

        n.global_position = start_pos
        create_tween().tween_property(n, "global_position", pos, 0.28)

    # connect died
    if enemy.has_signal("died"):
        enemy.connect("died", Callable(self, "_on_arena_enemy_died").bind(enemy))

func _spawn_to_max_legacy() -> void:
    _cleanup_dead()
    while enemies.size() < max_enemies:
        var scene := _pick_enemy_scene()
        var e: Node = scene.instantiate()
        add_child(e)
        e.name = "Enemy_%d" % Time.get_ticks_msec()
        e.global_position = Vector2(320 + enemies.size() * 34, 120)
        enemies.append(e)
        if e.has_signal("died"):
            e.died.connect(func(): _on_enemy_died(e))

func _cleanup_dead() -> void:
    var alive: Array[Node] = []
    for e in enemies:
        if e and is_instance_valid(e):
            alive.append(e)
    enemies = alive

func _pick_enemy_scene() -> PackedScene:
    var r := randf()
    if r < 0.4:
        return RUSHER_SCENE
    elif r < 0.7:
        return TANK_SCENE
    else:
        return RANGED_SCENE

func add_score(v: int) -> void:
    score += v
    if hud and hud.has_method("set_score"):
        hud.set_score(score)

func on_key_collected() -> void:
    if arena_active:
        return
    has_key = true
    if hud and hud.has_method("set_key"):
        hud.set_key(true)

func _drop_loot(pos: Vector2) -> void:
    var r := randf()
    if r < 0.5:
        var c = COIN_SCENE.instantiate()
        add_child(c)
        c.global_position = pos
    elif r < 0.75:
        var f = FOOD_SCENE.instantiate()
        add_child(f)
        f.global_position = pos
    
func _on_enemy_died(e: Node) -> void:
    add_score(100)
    if e and is_instance_valid(e):
        call_deferred("_drop_loot", e.global_position)
    if enemies.has(e):
        enemies.erase(e)

    # Durante arena no usamos el loop de spawn general
    if arena_active:
        return

    wave += 1
    _spawn_to_max_legacy()

func _pick_arena_spawn_point() -> Node2D:
    if arena_spawn_points.size() <= 0:
        return null
    var sp: Node = arena_spawn_points[randi() % arena_spawn_points.size()]
    return sp as Node2D

func _pick_arena_spawn_position() -> Vector2:
    var sp: Node2D = _pick_arena_spawn_point()
    if sp != null:
        return sp.global_position
    return Vector2.ZERO

func on_level_complete() -> void:
    add_score(250)
    print("âœ… STAGE CLEAR +250")
    await get_tree().create_timer(0.6).timeout

    var lm := get_node_or_null("/root/LevelManagerAuto")
    if lm:
        lm.call_deferred("next_level")
    else:
        # fallback (por si autoload no existe)
        get_tree().reload_current_scene()

func on_player_died() -> void:
    print("ðŸ” RESTARTING SCENE...")
    await get_tree().create_timer(0.8).timeout
    get_tree().reload_current_scene()

# --- Floating damage text (reusable) ---
func spawn_damage_text(pos: Vector2, amount: int) -> void:
    # Si existe un nodo/escena DamageText, lo instancia. Si no, usa texto flotante simple.
    if ResourceLoader.exists("res://scenes/DamageText.tscn"):
        var dt = preload("res://scenes/DamageText.tscn").instantiate()
        add_child(dt)
        dt.global_position = pos
        if dt.has_method("set_amount"):
            dt.set_amount(amount)
        elif dt.has_method("set_text"):
            dt.set_text(str(amount))
    else:
        # fallback: usa spawn_floating_text si estÃ¡
        if has_method("spawn_floating_text"):
            spawn_floating_text(pos, str(amount))
        else:
            print("DMG:", amount)

# Alias por compatibilidad
func spawn_floating_text(pos: Vector2, text: String) -> void:
    # Si te mandan string, intenta parsear nÃºmero; sino lo imprime como texto
    var n := int(text) if text.is_valid_int() else 0
    if n != 0:
        spawn_damage_text(pos, n)
    else:
        print("FLOAT:", text)

func _on_arena_trigger_body_entered(body: Node) -> void:
    if arena_active or arena_cleared:
        return
    if body == null:
        return
    if not body.is_in_group("player"):
        return    
    # solo el Player activa
    if body.name != "Player":
        return

    print("ðŸŸ¨ ArenaTrigger ENTER -> START ARENA")
    _start_arena()

func _spawn_arena_wave_legacy() -> void:
    print("ðŸ§ª _spawn_arena_wave() ENTER")

    var spawn_y := 170.0
    var spawns := [
        Vector2(320.0, spawn_y),
        Vector2(370.0, spawn_y),
        Vector2(420.0, spawn_y),
    ]
    var pool: Array[PackedScene] = [ENEMY_RUSHER, ENEMY_TANK, ENEMY_RANGED]

    for i in range(spawns.size()):
        var scene: PackedScene = pool[i % pool.size()]
        var e: Node2D = scene.instantiate()
        add_child(e)
        e.global_position = spawns[i]

        # contar vivos de arena
        arena_wave_left += 1

        # registrar tambiÃ©n para respawn general
        enemies.append(e)

        # marcar como enemigo de arena (opcional)
        e.add_to_group("arena_enemy")

        print("ðŸ§ª spawned arena enemy #", i, " wave_left=", arena_wave_left)

        if e.has_signal("died"):
            # 1) contador de arena
            e.died.connect(_on_arena_enemy_died)

        # spawn escalonado (Scott Pilgrim feel)
        await get_tree().create_timer(0.35).timeout

func _on_arena_enemy_died(enemy):
    arena_wave_left -= 1

    if arena_wave_left <= 0:
        if arena_waiting_next_wave:
            return
        arena_waiting_next_wave = true

        await get_tree().create_timer(1.25).timeout

        arena_waiting_next_wave = false
        _spawn_next_wave()

func _finish_arena():
    arena_active = false
    arena_cleared = true

    # âœ… dar llave SOLO al finalizar la arena
    _grant_arena_key()

    _lock_door(false)

func _grant_arena_key() -> void:
    if has_key:
        return
    has_key = true
    if hud and hud.has_method("set_key"):
        hud.set_key(true)

func _start_arena_legacy():
    arena_active = true
    arena_cleared = false
    arena_wave_left = 0
    
    # LEGACY: no usar en el sistema nuevo (se mantiene por referencia)
    print("ðŸ§ª _start_arena() -> calling _spawn_arena_wave()")
    _spawn_arena_wave_legacy()

    if door_node and door_node.has_method("set_locked"):
        door_node.call("set_locked", true)    

func _set_door_exit_enabled(enabled: bool) -> void:
    if door_node == null:
        return

    var exit_area: Area2D = door_node.get_node_or_null("ExitArea")
    if exit_area:
        exit_area.set_deferred("monitoring", enabled)
