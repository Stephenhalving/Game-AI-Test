extends CharacterBody2D

@export var speed := 170.0
@export var gravity := 1200.0
@export var jump_velocity := -420.0

@export var max_hp := 10
var hp := 10

var facing := 1.0
var invuln := 0.0
var hurt_timer := 0.0
var hurt_knock_x := 0.0

var last_action := "IDLE"
var action_timer := 0.0

var combo_step := 0
var combo_timer := 0.0
var combo_window := 0.35

var attack_cooldown := 0.0
var current_damage := 1
var current_knock := 260.0
var current_lift := 0.0
var last_attack_heavy := false

# evita multi-hit por misma ventana
var attack_consumed := false

@onready var attack_area: Area2D = $AttackArea 
@onready var body_poly: Polygon2D = $PlayerBody 
@onready var cam: Camera2D = $Camera2D 
@onready var anim: AnimationPlayer = $AnimationPlayer

func _ready() -> void:
        hp = max_hp
        attack_area.monitoring = false
        if not attack_area.body_entered.is_connected(_on_attack_area_body_entered):
                attack_area.body_entered.connect(_on_attack_area_body_entered)

        if anim:
                anim.play("idle")




func _do_heavy_attack() -> void:
                                last_attack_heavy = true
                                combo_step = 0
                                combo_timer = 0.0
                                current_damage = 2
                                current_knock = 420.0
                                current_lift = 420.0
                                _set_action("HEAVY", 0.26)
                                attack_cooldown = 0.22
                                _do_attack_window()

func _do_combo_attack() -> void:
        last_attack_heavy = false

        # Si se venció la ventana, reinicia el combo
        if combo_timer <= 0.0:
                combo_step = 1
        else:
                combo_step += 1
                if combo_step > 3:
                        combo_step = 1

        # HUD combo text (x1/x2/x3)
        var main := get_tree().current_scene
        if main and main.has_node("HUD"):
                var h := main.get_node("HUD")
                if h and h.has_method("set_combo"):
                        h.set_combo("x%d" % combo_step)

        # Aplicar stats por golpe
        if combo_step == 1:
                current_damage = 1
                current_knock = 220.0
                current_lift = 0.0
                _set_action("ATK1", 0.18)
        elif combo_step == 2:
                current_damage = 1
                current_knock = 260.0
                current_lift = 0.0
                _set_action("ATK2", 0.18)
        else:
                current_damage = 2
                current_knock = 360.0
                current_lift = 180.0
                _set_action("ATK3", 0.22)

        attack_cooldown = 0.12
        combo_timer = combo_window
        _do_attack_window()

func _do_attack_window() -> void:
                                attack_consumed = false
                                attack_area.position.x = 18.0 * facing
                                attack_area.set_deferred("monitoring", true)

                                # Esperar 1 frame de física para que el motor compute overlaps
                                await get_tree().physics_frame

                                # Si ya estaba solapando, body_entered no siempre dispara: pegamos por overlap también
                                var bodies: Array[Node2D] = attack_area.get_overlapping_bodies()

                                for b in bodies:
                                                                if attack_consumed:
                                                                                                break
                                                                _on_attack_area_body_entered(b)

                                # Ventana activa del hitbox (por si entra alguien durante el golpe)
                                await get_tree().create_timer(0.10).timeout
                                attack_area.set_deferred("monitoring", false)



func _on_attack_area_body_entered(body: Node) -> void:
                                # aplica daño si el target soporta take_hit
                                if body == self:
                                                                return
                                if body.has_method("take_hit") and not attack_consumed:
                                                                attack_consumed = true
                                                                body.take_hit(facing, current_knock, current_damage, current_lift)

                                                                # hitstop si existe
                                                                var main: Node = get_tree().current_scene
                                                                if main and main.has_method("hitstop"):
                                                                                                if last_attack_heavy:
                                                                                                                                main.hitstop(0.09, 0.04)
                                                                                                else:
                                                                                                                                main.hitstop(0.05, 0.08)

                                                                # shake si existe
                                                                if last_attack_heavy and has_method("_shake_cam"):
                                                                                                _shake_cam(4.0, 0.11)

func take_damage(from_dir: float, dmg: int = 1, knock: float = 360.0) -> void:
                                if invuln > 0.0:
                                                                return
                                hp -= dmg
                                invuln = 0.8
                                hurt_timer = 0.18
                                hurt_knock_x = knock * from_dir
                                _set_action("HURT", 0.25)
                                if hp <= 0:
                                                                _set_action("KO", 1.0)

func _set_action(name: String, seconds: float) -> void:
                                last_action = name
                                action_timer = seconds


# --- Camera shake helper (seguro) ---
func _shake_cam(intensity: float = 3.0, duration: float = 0.10) -> void:
                                if not cam:
                                                                return
                                var base: Vector2 = cam.position
                                var steps: int = 6
                                var step_t: float = duration / float(steps)
                                if step_t < 0.01:
                                                                step_t = 0.01
                                for i in range(steps):
                                                                var off: Vector2 = Vector2(randf_range(-intensity, intensity), randf_range(-intensity, intensity))
                                                                cam.position = base + off
                                                                await get_tree().create_timer(step_t).timeout
                                cam.position = base
