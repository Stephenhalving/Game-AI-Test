extends CharacterBody2D

@export var speed := 170.0
@export var gravity := 1200.0
@export var jump_velocity := -420.0

@export var max_hp := 10
var hp := 10

var facing := 1.0
var invuln := 0.0
var hurt_timer := 0.0
var hurt_knock_x := 0.0

var last_action := "IDLE"
var action_timer := 0.0

var combo_step := 0
var combo_timer := 0.0
var combo_window := 0.35

var attack_cooldown := 0.0
var current_damage := 1
var current_knock := 260.0
var current_lift := 0.0
var last_attack_heavy := false

# evita multi-hit por misma ventana
var attack_consumed := false

@onready var attack_area: Area2D = $AttackArea 
@onready var body_poly: Polygon2D = $PlayerBody 
@onready var cam: Camera2D = $Camera2D 
@onready var anim: AnimationPlayer = $AnimationPlayer

func _ready() -> void:
		hp = max_hp
		attack_area.monitoring = false
		if not attack_area.body_entered.is_connected(_on_attack_area_body_entered):
				attack_area.body_entered.connect(_on_attack_area_body_entered)

		if anim:
				anim.play("idle")


func _physics_process(delta: float) -> void:
		action_timer = max(0.0, action_timer - delta)
		attack_cooldown = max(0.0, attack_cooldown - delta)
		combo_timer = max(0.0, combo_timer - delta)
		invuln = max(0.0, invuln - delta)
		hurt_timer = max(0.0, hurt_timer - delta)

		var dir := Input.get_axis("move_left", "move_right")
		var pressed_jump := Input.is_action_just_pressed("jump")
		var pressed_attack := Input.is_action_just_pressed("attack")
		var pressed_heavy := Input.is_action_just_pressed("heavy")

		if dir < -0.01:
				facing = -1.0
		elif dir > 0.01:
				facing = 1.0

		# --- VISUAL FLIP (arcade) ---
		if body_poly:
				body_poly.scale.x = abs(body_poly.scale.x) * facing

		var can_control := (hurt_timer <= 0.0)

		# heavy (K)
		if pressed_heavy and attack_cooldown <= 0.0 and can_control:
				_do_heavy_attack()

		# combo normal (J)
		if pressed_attack and attack_cooldown <= 0.0 and can_control:
				_do_combo_attack()

		if not is_on_floor():
				velocity.y += gravity * delta
		else:
				if pressed_jump and can_control:
						velocity.y = jump_velocity
						_set_action("JUMP", 0.25)

		# --- APPLY HORIZONTAL MOVE (FIX A/D) ---
		if can_control:
				velocity.x = dir * speed
		else:
				velocity.x = hurt_knock_x

		# --- Basic animation switch ---
		if can_control:
				if abs(velocity.x) > 1.0 and is_on_floor():
						if anim and anim.current_animation != "run":
								anim.play("run")
				else:
						if anim and anim.current_animation != "idle":
								anim.play("idle")

		move_and_slide()

		# blink invuln
		body_poly.visible = true if int(Time.get_ticks_msec() / 80) % 2 == 0 or invuln <= 0.0 else false

func _do_heavy_attack() -> void:
								last_attack_heavy = true
								combo_step = 0
								combo_timer = 0.0
								current_damage = 2
								current_knock = 420.0
								current_lift = 420.0
								_set_action("HEAVY", 0.26)
								attack_cooldown = 0.22
								_do_attack_window()

func _do_combo_attack() -> void:
		last_attack_heavy = false

		# Si se venció la ventana, reinicia el combo
		if combo_timer <= 0.0:
				combo_step = 1
		else:
				combo_step += 1
				if combo_step > 3:
						combo_step = 1

		# HUD combo text (x1/x2/x3)
		var main := get_tree().current_scene
		if main and main.has_node("HUD"):
				var h := main.get_node("HUD")
				if h and h.has_method("set_combo"):
						h.set_combo("x%d" % combo_step)

		# Aplicar stats por golpe
		if combo_step == 1:
				current_damage = 1
				current_knock = 220.0
				current_lift = 0.0
				_set_action("ATK1", 0.18)
		elif combo_step == 2:
				current_damage = 1
				current_knock = 260.0
				current_lift = 0.0
				_set_action("ATK2", 0.18)
		else:
				current_damage = 2
				current_knock = 360.0
				current_lift = 180.0
				_set_action("ATK3", 0.22)

		attack_cooldown = 0.12
		combo_timer = combo_window
		_do_attack_window()

func _do_attack_window() -> void:
								attack_consumed = false
								attack_area.position.x = 18.0 * facing
								attack_area.set_deferred("monitoring", true)

								# Esperar 1 frame de física para que el motor compute overlaps
								await get_tree().physics_frame

								# Si ya estaba solapando, body_entered no siempre dispara: pegamos por overlap también
								var bodies: Array[Node2D] = attack_area.get_overlapping_bodies()

								for b in bodies:
																if attack_consumed:
																								break
																_on_attack_area_body_entered(b)

								# Ventana activa del hitbox (por si entra alguien durante el golpe)
								await get_tree().create_timer(0.10).timeout
								attack_area.set_deferred("monitoring", false)



func _on_attack_area_body_entered(body: Node) -> void:
								# aplica daño si el target soporta take_hit
								if body == self:
																return
								if body.has_method("take_hit") and not attack_consumed:
																attack_consumed = true
																body.take_hit(facing, current_knock, current_damage, current_lift)

																# hitstop si existe
																var main: Node = get_tree().current_scene
																if main and main.has_method("hitstop"):
																								if last_attack_heavy:
																																main.hitstop(0.09, 0.04)
																								else:
																																main.hitstop(0.05, 0.08)

																# shake si existe
																if last_attack_heavy and has_method("_shake_cam"):
																								_shake_cam(4.0, 0.11)

func take_damage(from_dir: float, dmg: int = 1, knock: float = 360.0) -> void:
								if invuln > 0.0:
																return
								hp -= dmg
								invuln = 0.8
								hurt_timer = 0.18
								hurt_knock_x = knock * from_dir
								_set_action("HURT", 0.25)
								if hp <= 0:
																_set_action("KO", 1.0)

func _set_action(name: String, seconds: float) -> void:
								last_action = name
								action_timer = seconds


# --- Camera shake helper (seguro) ---
func _shake_cam(intensity: float = 3.0, duration: float = 0.10) -> void:
								if not cam:
																return
								var base: Vector2 = cam.position
								var steps: int = 6
								var step_t: float = duration / float(steps)
								if step_t < 0.01:
																step_t = 0.01
								for i in range(steps):
																var off: Vector2 = Vector2(randf_range(-intensity, intensity), randf_range(-intensity, intensity))
																cam.position = base + off
																await get_tree().create_timer(step_t).timeout
								cam.position = base
